package com.nala.businesslogic.viewmodelimport android.text.TextUtilsimport androidx.core.widget.NestedScrollViewimport androidx.databinding.ObservableArrayListimport androidx.databinding.ObservableBooleanimport androidx.databinding.ObservableIntimport androidx.databinding.ObservableListimport androidx.recyclerview.widget.GridLayoutManagerimport androidx.recyclerview.widget.LinearLayoutManagerimport androidx.recyclerview.widget.RecyclerViewimport androidx.swiperefreshlayout.widget.SwipeRefreshLayout.OnRefreshListenerimport com.nala.Rimport com.nala.businesslogic.interactors.ObservableStringimport com.nala.businesslogic.pojo.PojoCommonResponseimport com.nala.businesslogic.sharedpreference.UtilsSharedPreferencesimport com.nala.utils.ConstantCodes.Companion.TOTAL_RECORDSimport com.nala.view.MyApplicationimport com.bumptech.glide.request.RequestOptionsimport org.json.JSONObjectimport retrofit2.Callimport retrofit2.Callbackimport retrofit2.Responseabstract class ViewModelRecyclerView<X, T>(    var application: MyApplication,    var isOfflineEnabled: Boolean,    var isGridLayoutManager: Boolean,    var spanCount: Int,    var isOrientation: Int) {    protected var mApplication: MyApplication? = null    protected var mPreferences: UtilsSharedPreferences? = null    var observerProgressBar = ObservableBoolean(false)    var layoutManager: LinearLayoutManager? = null    protected var mOffset: Int = 0    private var mTotalCount: Int = 0    private var mSpanCount = 2    private var mOrientation = RecyclerView.VERTICAL    protected var mIsClearData = false    private var mIsFromLastItem = false    private var mShowCentreProgress = true    private var mIsOfflineEnabled = false    private var mIsGridLayoutManager = false    var observerEnabledSwipeRefresh = ObservableBoolean(true)    var observerSwipeRefreshing = ObservableBoolean(false)    var observerSnackBarInt: ObservableInt = ObservableInt()    var observerSnackBarString: ObservableString = ObservableString("")    var observerNoRecords: ObservableInt = ObservableInt(R.string.text_norecordfound)    var observerIsFilterActive = ObservableBoolean(false)    var observerFilterString: ObservableString = ObservableString("")    var requestOptionCentreProfilePic: RequestOptions? = null    var observerContent: ObservableList<T?> = ObservableArrayList()    var observerContentSearch: ObservableList<T> = ObservableArrayList()    init {        mApplication = application        mPreferences = mApplication!!.getAppComponent().getPreferences()        mIsOfflineEnabled = isOfflineEnabled        mIsGridLayoutManager = isGridLayoutManager        mOrientation = isOrientation        mSpanCount = spanCount        if (mIsGridLayoutManager) {            layoutManager = GridLayoutManager(mApplication, spanCount, isOrientation, false)        } else {            layoutManager = LinearLayoutManager(mApplication, isOrientation, false)        }        requestOptionCentreProfilePic =            application.glideCenterCircle()    }    open fun <Y> isNotNullEmptyRandom(array: List<Y>?): Boolean {        return array != null && !array.isEmpty()    }    private fun isNotNullEmpty(array: ObservableList<T?>?): Boolean {        return array != null && !array.isEmpty()    }    /**     * Updates parameters for on scroll     */    private fun updateOnScroll() {        mIsFromLastItem = true        mShowCentreProgress = false        mIsClearData = false        //mPageIndex++    }    /**     * Updates parameters for on refresh     */    private fun updateOnRefresh() {        mIsFromLastItem = false        mShowCentreProgress = false        mIsClearData = true    }    /**     * Updates parameters for network call     */    private fun updateRefreshContents() {        if (mShowCentreProgress) {            observerProgressBar.set(true)        }        if (mIsClearData) {            mOffset = 0        } else if (mIsFromLastItem) {            observerContent.add(null)        }    }    /**     * Checks for onScroll possibility     *     * @param dy Difference in Y for the scroll     * @return Possibility of scroll     */    private fun checkForScroll(dy: Int): Boolean {        val totalItemCount = layoutManager!!.itemCount        val pastVisibleItems = layoutManager!!.findLastCompletelyVisibleItemPosition()        return dy > 0 && !observerProgressBar.get() && totalItemCount < mTotalCount &&                mOffset <= pastVisibleItems + 2    }    /**     * Scroll change listener for nested scroll view     */    var scrollChangeListener =        NestedScrollView.OnScrollChangeListener { v: NestedScrollView, scrollX: Int, scrollY: Int, oldScrollX: Int, oldScrollY: Int ->            if (v.getChildAt(v.childCount - 1) != null &&                scrollY >= v.getChildAt(v.childCount - 1).measuredHeight - v                    .measuredHeight && scrollY > oldScrollY && checkForScroll(1)            ) {                onScroll()            }        }    /**     * Scroll listener for recycler view     */    var scrollListener: RecyclerView.OnScrollListener = object : RecyclerView.OnScrollListener() {        override fun onScrollStateChanged(recyclerView: RecyclerView, newState: Int) {            observerEnabledSwipeRefresh.set(layoutManager!!.findFirstCompletelyVisibleItemPosition() <= 0)        }        override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {            super.onScrolled(recyclerView, dx, dy)            if (checkForScroll(dy)) {                onScroll()            }        }    }    /**     * Takes necessary action for onScroll     */    private fun onScroll() {        if (mApplication!!.isInternetConnected()) {            updateOnScroll()            fetchDataList()        } else {            observerSnackBarInt.set(R.string.message_noconnection)        }    }    /**     * Refresh listener for swipe to refresh     */    var refreshListener = OnRefreshListener { refreshContent() }    /**     * Refreshes content for the list depending on the connectivity     *     *     * If connected then from api, else gets data offline     */    open fun refreshContent() {        observerSwipeRefreshing.set(true)        if (mApplication!!.isInternetConnected()) {            if (!observerProgressBar.get()) {                refreshListUpdate()                updateOnRefresh()                fetchDataList()            } else {                observerSwipeRefreshing.set(false)            }        } else {            observerSwipeRefreshing.set(false)            offlineDataList()        }    }    abstract fun refreshListUpdate()    abstract fun networkCallList()    /**     * Takes care of data fetch, if net connected then network call else checks for offline is     * enabled or not, if enabled then takes data from database else shows no connection     */    open fun fetchDataList() {        if (mApplication!!.isInternetConnected()) {            updateRefreshContents()            networkCallList()        } else {            if (mIsOfflineEnabled) {                offlineDataList()            } else {                observerSnackBarInt.set(R.string.message_noconnection)            }        }    }    abstract fun offlineDataList()    abstract fun sendResponseBodyList(list: X?)    /**     * Callback for network call     */    protected var mCallbackList: Callback<X> = object : Callback<X> {        override fun onResponse(call: Call<X>, response: Response<X>) {            removeFooter()            if (response.isSuccessful && response.body() != null) {                val body = response.body()                val commonResponse = body as PojoCommonResponse                if (commonResponse.getStatus()!!) {                    //clearDataOnResponse();                    mTotalCount = commonResponse.getTotalCount()!!                    mOffset = commonResponse.getOffset()!!                    sendResponseBodyList(response.body())                } else if (!TextUtils.isEmpty(commonResponse.getMessage())) {                    observerSnackBarString.set(commonResponse.getMessage())                } else {                    observerSnackBarInt.set(R.string.message_something_wrong)                }            } else if (response.errorBody() != null) {                try {                    val jObjError = JSONObject(response.errorBody()!!.string())                    val message = jObjError.getString("message")                    if (!TextUtils.isEmpty(message))                        observerSnackBarString.set(message)                    else                        observerSnackBarInt.set(R.string.message_something_wrong)                } catch (e: Exception) {                    observerSnackBarInt.set(R.string.message_something_wrong)                }            } else {                observerSnackBarInt.set(R.string.message_something_wrong)            }            observerProgressBar.set(false)            observerSwipeRefreshing.set(false)        }        override fun onFailure(call: Call<X?>, t: Throwable) {            removeFooter()            observerSnackBarInt.set(R.string.message_something_wrong)            observerProgressBar.set(false)            observerSwipeRefreshing.set(false)        }        /**         * Clears data on response success if its is to be cleared         */        private fun clearDataOnResponse() {            if (mIsClearData) {                mTotalCount = 0                observerContent.clear()                observerContentSearch.clear()            }        }        /**         * Removes footer depending on the last item in contention or not         */        private fun removeFooter() {            if (mIsFromLastItem && isNotNullEmpty(observerContent)) {                observerContent.removeAt(observerContent.size - 1)            }        }    }    open fun setProgressBar(visible: Boolean?) {        observerProgressBar.set(visible!!)    }}